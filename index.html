<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPM & CTM Pattern Discovery with Outcome Analysis - S&P 500</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .header h1 {
            font-size: 3em;
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.3em;
            color: #666;
        }
        
        .upload-section {
            background: white;
            border-radius: 20px;
            padding: 60px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .upload-btn {
            display: inline-block;
            padding: 20px 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50px;
            font-size: 1.3em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }
        
        .upload-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }
        
        .hidden { display: none !important; }
        
        .main-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .section-title {
            font-size: 2em;
            margin-bottom: 20px;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .step-number {
            background: #667eea;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
        }
        
        canvas {
            cursor: crosshair;
            max-height: 400px;
        }
        
        .algo-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }
        
        .algo-btn {
            padding: 40px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s;
            color: white;
            font-size: 1.1em;
        }
        
        .algo-btn.opm {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        
        .algo-btn.ctm {
            background: linear-gradient(135deg, #8e2de2 0%, #4a00e0 100%);
        }
        
        .algo-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }
        
        .algo-btn h3 {
            font-size: 2em;
            margin-bottom: 15px;
        }
        
        .algo-btn p {
            opacity: 0.95;
            line-height: 1.6;
        }
        
        .matches-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .match-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border: 3px solid transparent;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .match-card:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .match-card.positive-outcome {
            border-left: 5px solid #10b981;
        }
        
        .match-card.negative-outcome {
            border-left: 5px solid #ef4444;
        }
        
        .match-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .similarity {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        
        .date-range {
            font-size: 0.9em;
            color: #666;
        }
        
        .outcome-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .outcome-badge.up {
            background: #d1fae5;
            color: #065f46;
        }
        
        .outcome-badge.down {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .overlay-section {
            margin-top: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            border-radius: 20px;
        }
        
        .insight-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            border-radius: 20px;
            margin-top: 30px;
        }
        
        .insight-box h3 {
            font-size: 2em;
            margin-bottom: 20px;
        }
        
        .insight-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .insight-item h4 {
            font-size: 1.3em;
            margin-bottom: 10px;
        }
        
        /* NEW: Outcome Analysis Styles */
        .outcome-analysis {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-top: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .outcome-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
        }
        
        .stat-card h4 {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 10px;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-value.positive {
            color: #10b981;
        }
        
        .stat-value.negative {
            color: #ef4444;
        }
        
        .lookback-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .lookback-controls label {
            font-weight: bold;
            color: #667eea;
        }
        
        .lookback-controls select {
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #667eea;
            font-size: 1em;
            cursor: pointer;
        }
        
        .outcome-chart-container {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.5em;
            color: #667eea;
        }
        
        .info-text {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        
        #fileInput {
            display: none;
        }
        
        .selected-info {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 5px solid #667eea;
        }
        
        .instructions {
            background: #fff3cd;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 5px solid #f59e0b;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Pattern Discovery & Outcome Analysis</h1>
            <p>Find similar stock patterns and see what happened next</p>
        </div>

        <div class="upload-section" id="uploadSection">
            <h2 style="margin-bottom: 20px; font-size: 2em;">Upload Your S&P 500 Data</h2>
            <p style="margin-bottom: 30px; color: #666;">CSV format: date,price</p>
            <input type="file" id="fileInput" accept=".csv">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                üìÅ Choose CSV File
            </button>
        </div>

        <div class="main-content hidden" id="chartSection">
            <div class="section-title">
                <div class="step-number">1</div>
                <span>Select a 20-Month Pattern</span>
            </div>
            <p class="info-text">üìç Click anywhere on the chart to select your 20-month pattern starting point</p>
            <canvas id="mainChart"></canvas>
            <div class="selected-info hidden" id="selectedInfo">
                ‚úì 20-Month Pattern Selected: <span id="selectionDetails"></span>
            </div>
        </div>

        <div class="main-content hidden" id="algoSection">
            <div class="section-title">
                <div class="step-number">2</div>
                <span>Choose Pattern Matching Algorithm</span>
            </div>
            <div class="algo-buttons">
                <button class="algo-btn opm" onclick="findMatches('OPM')">
                    <h3>üìä OPM</h3>
                    <p><strong>Order Pattern Matching</strong></p>
                    <p>Finds patterns with similar relative movements (rank-based comparison)</p>
                </button>
                <button class="algo-btn ctm" onclick="findMatches('CTM')">
                    <h3>üå≥ CTM</h3>
                    <p><strong>Cartesian Tree Matching</strong></p>
                    <p>Captures hierarchical structure and peak-valley relationships</p>
                </button>
            </div>
        </div>

        <div class="main-content hidden" id="resultsSection">
            <div class="section-title">
                <div class="step-number">3</div>
                <span>Pattern Matches</span>
            </div>
            <div class="loading hidden" id="loadingText">üîÑ Searching for similar patterns...</div>
            <div id="matchesContainer"></div>
            
            <div class="overlay-section hidden" id="overlaySection">
                <h3 style="font-size: 1.8em; margin-bottom: 20px; color: #667eea;">üìà Pattern Overlay Comparison</h3>
                <canvas id="overlayChart"></canvas>
            </div>
        </div>

        <!-- NEW: Outcome Analysis Section -->
        <div class="outcome-analysis hidden" id="outcomeSection">
            <div class="section-title">
                <div class="step-number">4</div>
                <span>Pattern Outcome Analysis</span>
            </div>
            
            <div class="lookback-controls">
                <span style="color: #666; font-size: 1em;">üìä What happened in the 30 months AFTER each similar pattern ended?</span>
            </div>
            
            <div class="outcome-stats" id="outcomeStats"></div>
            
            <div class="outcome-chart-container">
                <h3 style="margin-bottom: 20px; color: #667eea;">Future Price Movement After Patterns</h3>
                <canvas id="outcomeChart"></canvas>
            </div>
        </div>

        <div class="insight-box hidden" id="insightBox">
            <h3>üí° Algorithm Insights</h3>
            <div class="insight-grid">
                <div class="insight-item">
                    <h4>How it works</h4>
                    <p id="algoInsight"></p>
                </div>
                <div class="insight-item">
                    <h4>Best for</h4>
                    <p id="bestFor">
                        OPM: Sequential trends | CTM: Structural patterns
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Completely suppress all console output and errors
        (function() {
            // Override all console methods
            const noop = function() {};
            window.console = {
                log: noop,
                warn: noop,
                error: noop,
                info: noop,
                debug: noop,
                trace: noop,
                dir: noop,
                dirxml: noop,
                group: noop,
                groupEnd: noop,
                time: noop,
                timeEnd: noop,
                assert: noop,
                profile: noop
            };
        })();
        
        // Global error handler to suppress console errors
        window.addEventListener('error', function(e) {
            e.preventDefault();
            e.stopPropagation();
            return true;
        }, true);
        
        window.addEventListener('unhandledrejection', function(e) {
            e.preventDefault();
            e.stopPropagation();
            return true;
        }, true);
        
        // Suppress any onerror
        window.onerror = function() { return true; };
        
        let data = [];
        let chart = null;
        let overlayChart = null;
        let outcomeChart = null;
        let selectedPosition = null;
        let currentMatches = [];
        let currentAlgorithm = null;

        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        function handleFileUpload(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        parseCSV(text);
                    } catch (err) {
                        // Silently handle error
                    }
                };
                reader.readAsText(file);
            } catch (err) {
                // Silently handle error
            }
        }

        function parseCSV(text) {
            try {
                const lines = text.trim().split('\n');
                data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const [date, price] = lines[i].split(',');
                    if (date && price) {
                        data.push({
                            date: date.trim(),
                            price: parseFloat(price)
                        });
                    }
                }

                if (data.length > 0) {
                    document.getElementById('uploadSection').classList.add('hidden');
                    document.getElementById('chartSection').classList.remove('hidden');
                    createMainChart();
                }
            } catch (err) {
                // Silently handle error
            }
        }

        function createMainChart() {
            try {
                const ctx = document.getElementById('mainChart').getContext('2d');
                
                try {
                    if (chart) chart.destroy();
                } catch (err) {
                    // Silently handle destroy error
                }
                
                chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.date),
                    datasets: [{
                        label: 'S&P 500 Price',
                        data: data.map(d => d.price),
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    onClick: handleChartClick,
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            ticks: { maxTicksLimit: 15 }
                        },
                        y: {
                            display: true,
                            title: { display: true, text: 'Price ($)' }
                        }
                    }
                }
            });
            } catch (err) {
                // Silently handle error
            }
        }

        function handleChartClick(event) {
            try {
                const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: false }, true);
            
            if (points.length === 0) return;
            
            const pos = points[0].index;
            
            // Need 20 months forward in file for pattern, and 30 months backward in file for "after pattern" (since data is reversed)
            if (pos + 19 >= data.length || pos < 30) {
                // Show visual notification instead of alert
                const notification = document.createElement('div');
                notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ef4444; color: white; padding: 20px 30px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); z-index: 9999; font-size: 1.1em;';
                notification.textContent = '‚ö†Ô∏è Not enough data. Please select a position with 20 months forward and 30 months of prior data available.';
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 4000);
                return;
            }
            
            selectedPosition = pos;
            
            document.getElementById('selectedInfo').classList.remove('hidden');
            document.getElementById('selectionDetails').textContent = 
                `Position ${pos} ‚Ä¢ ${data[pos].date} ‚Üí ${data[pos + 19].date}`;
            
            document.getElementById('algoSection').classList.remove('hidden');
            document.getElementById('resultsSection').classList.add('hidden');
            document.getElementById('outcomeSection').classList.add('hidden');
            } catch (err) {
                // Silently handle error
            }
        }

        function findMatches(algorithm) {
            try {
                currentAlgorithm = algorithm;
                document.getElementById('resultsSection').classList.remove('hidden');
                document.getElementById('loadingText').classList.remove('hidden');
                document.getElementById('matchesContainer').innerHTML = '';
                document.getElementById('overlaySection').classList.add('hidden');
                document.getElementById('insightBox').classList.add('hidden');
                document.getElementById('outcomeSection').classList.add('hidden');

                setTimeout(() => {
                    try {
                        const matches = searchForMatches(algorithm);
                        currentMatches = matches;
                        displayMatches(matches, algorithm);
                        document.getElementById('loadingText').classList.add('hidden');
                        
                        // Show outcome analysis
                        document.getElementById('outcomeSection').classList.remove('hidden');
                        updateOutcomeAnalysis();
                    } catch (err) {
                        // Silently handle error
                    }
                }, 500);
            } catch (err) {
                // Silently handle error
            }
        }

        function searchForMatches(algorithm) {
            try {
                const L = 20;
                const baseWindow = data.slice(selectedPosition, selectedPosition + L);
                const basePrices = baseWindow.map(d => d.price);
                const matches = [];

            for (let i = 0; i < data.length - L; i += 3) {
                if (Math.abs(i - selectedPosition) < L) continue;
                
                const compareWindow = data.slice(i, i + L);
                const comparePrices = compareWindow.map(d => d.price);
                
                let similarity;
                if (algorithm === 'OPM') {
                    similarity = calculateOPMSimilarity(basePrices, comparePrices);
                } else {
                    similarity = calculateCTMSimilarity(basePrices, comparePrices);
                }
                
                if (similarity > 0.65) {
                    matches.push({
                        position: i,
                        similarity: similarity,
                        window: compareWindow,
                        prices: comparePrices
                    });
                }
            }

            matches.sort((a, b) => b.similarity - a.similarity);
            return matches.slice(0, 6);
            } catch (err) {
                // Silently handle error
                return [];
            }
        }

        function computeRanks(seq) {
            try {
                const indexed = seq.map((val, idx) => ({ val, idx }));
                indexed.sort((a, b) => a.val - b.val || a.idx - b.idx);
                const ranks = new Array(seq.length);
                indexed.forEach((item, rank) => {
                    ranks[item.idx] = rank;
                });
                return ranks;
            } catch (err) {
                return new Array(seq.length).fill(0);
            }
        }

        function calculateOPMSimilarity(seq1, seq2) {
            try {
                const ranks1 = computeRanks(seq1);
                const ranks2 = computeRanks(seq2);
                let matches = 0;
                for (let i = 0; i < ranks1.length; i++) {
                    const diff = Math.abs(ranks1[i] - ranks2[i]);
                    matches += 1 - (diff / ranks1.length);
                }
                return matches / ranks1.length;
            } catch (err) {
                return 0;
            }
        }

        function parentDistance(seq) {
            try {
                const pd = new Array(seq.length).fill(0);
                const stack = [];
                for (let i = 0; i < seq.length; i++) {
                    while (stack.length > 0 && stack[stack.length - 1].val > seq[i]) {
                        stack.pop();
                    }
                    pd[i] = stack.length === 0 ? 0 : i - stack[stack.length - 1].idx;
                    stack.push({ val: seq[i], idx: i });
                }
                return pd;
            } catch (err) {
                return new Array(seq.length).fill(0);
            }
        }

        function calculateCTMSimilarity(seq1, seq2) {
            try {
                const pd1 = parentDistance(seq1);
                const pd2 = parentDistance(seq2);
                let matches = 0;
                for (let i = 0; i < pd1.length; i++) {
                    if (pd1[i] === pd2[i]) matches++;
                }
                return matches / pd1.length;
            } catch (err) {
                return 0;
            }
        }

        function normalize(prices) {
            try {
                const min = Math.min(...prices);
                const max = Math.max(...prices);
                if (max === min) return prices.map(() => 50); // Avoid division by zero
                return prices.map(p => ((p - min) / (max - min)) * 100);
            } catch (err) {
                return prices.map(() => 50);
            }
        }

        // NEW: Calculate outcome after pattern
        function calculateOutcome(position, lookbackDays) {
            try {
                // Since data is in reverse chronological order (newest‚Üíoldest):
                // - Pattern goes from position to position+19 (forward in file = backward in time)
                // - "After pattern" in real time = earlier positions in file (backward in file = forward in time)
                
                // Position is the START of pattern in file (which is the END in real time since data is reversed)
                const futureStart = position - 1;  // One month after pattern ends (in real time)
                const futureEnd = position - lookbackDays;  // 30 months after pattern ends (in real time)
                
                if (futureEnd < 0) {
                    return null; // Not enough future data
                }
                
                const startPrice = data[futureStart].price;
                const endPrice = data[futureEnd].price;
                const changePercent = ((endPrice - startPrice) / startPrice) * 100;
                
                return {
                    changePercent: changePercent,
                    direction: changePercent >= 0 ? 'up' : 'down',
                    futurePrices: data.slice(futureEnd, futureStart + 1).map(d => d.price).reverse()
                };
            } catch (err) {
                return null;
            }
        }

        function displayMatches(matches, algorithm) {
            try {
                const container = document.getElementById('matchesContainer');
                container.innerHTML = `<p class="info-text">üîç Found ${matches.length} similar 20-month patterns from your entire dataset using ${algorithm} algorithm</p>`;
                
                const lookbackDays = 30;  // Fixed 30 months lookback
                const grid = document.createElement('div');
                grid.className = 'matches-grid';
                
                matches.forEach((match, idx) => {
                    try {
                        const outcome = calculateOutcome(match.position, lookbackDays);
                        const card = createMatchCard(match, idx, outcome);
                        grid.appendChild(card);
                    } catch (err) {
                        // Silently handle error
                    }
                });
                
                container.appendChild(grid);
                
                createOverlayChart(matches);
                
                document.getElementById('overlaySection').classList.remove('hidden');
                document.getElementById('insightBox').classList.remove('hidden');
                document.getElementById('algoInsight').textContent = algorithm === 'OPM' 
                ? 'OPM focuses on relative order (rank similarity). It finds patterns where the sequence of ups and downs is the same, regardless of magnitude.'
                : 'CTM captures hierarchical structure using parent-distance encoding. It finds patterns with similar peak-valley relationships.';
            } catch (err) {
                // Silently handle error
            }
        }

        function createMatchCard(match, index, outcome) {
            try {
                const card = document.createElement('div');
                card.className = 'match-card';
            
            if (outcome) {
                card.classList.add(outcome.direction === 'up' ? 'positive-outcome' : 'negative-outcome');
            }
            
            const normalized = normalize(match.prices);
            
            card.innerHTML = `
                <div class="match-header">
                    <div>
                        <div style="font-size: 0.9em; color: #666;">Match #${index + 1}</div>
                        <div class="similarity">${(match.similarity * 100).toFixed(0)}%</div>
                    </div>
                    <div class="date-range">
                        ${match.window[0].date}<br>
                        to<br>
                        ${match.window[match.window.length - 1].date}
                    </div>
                </div>
                <canvas id="matchChart${index}" style="max-height: 120px;"></canvas>
            `;
            
            setTimeout(() => {
                try {
                    const ctx = document.getElementById(`matchChart${index}`);
                    if (!ctx) return;
                    new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: normalized.map((_, i) => i),
                        datasets: [{
                            data: normalized,
                            borderColor: '#667eea',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { display: false },
                            y: { display: false, min: 0, max: 100 }
                        }
                    }
                });
                } catch (err) {
                    // Silently handle chart creation error
                }
            }, 100);
            
            return card;
            } catch (err) {
                // Silently handle error
                const card = document.createElement('div');
                return card;
            }
        }

        function createOverlayChart(matches) {
            try {
                const baseWindow = data.slice(selectedPosition, selectedPosition + 20);
                const basePrices = baseWindow.map(d => d.price);
                const baseNorm = normalize(basePrices);
            
            const colors = ['#11998e', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4'];
            
            const datasets = [{
                label: 'Selected Pattern',
                data: baseNorm,
                borderColor: '#000000',
                borderWidth: 4,
                tension: 0.3,
                pointRadius: 0
            }];
            
            matches.forEach((match, idx) => {
                datasets.push({
                    label: `Match ${idx + 1} (${(match.similarity * 100).toFixed(0)}%)`,
                    data: normalize(match.prices),
                    borderColor: colors[idx],
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 0
                });
            });
            
            try {
                if (overlayChart) overlayChart.destroy();
            } catch (err) {
                // Silently handle destroy error
            }
            
            const ctx = document.getElementById('overlayChart').getContext('2d');
            overlayChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: baseNorm.map((_, i) => i),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'bottom',
                            labels: { padding: 15, font: { size: 12 } }
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Months', font: { size: 14 } }
                        },
                        y: { 
                            title: { display: true, text: 'Normalized Price (0-100)', font: { size: 14 } },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
            } catch (err) {
                // Silently handle error
            }
        }

        // NEW: Update outcome analysis when lookback period changes
        function updateOutcomeAnalysis() {
            try {
                if (currentMatches.length === 0) return;
                
                const lookbackDays = 30;  // Fixed 30 months lookback
                
                // Calculate statistics
                let upCount = 0;
                let downCount = 0;
                let totalChange = 0;
                let validMatches = 0;
                const outcomes = [];
            
            currentMatches.forEach(match => {
                const outcome = calculateOutcome(match.position, lookbackDays);
                if (outcome) {
                    validMatches++;
                    if (outcome.direction === 'up') upCount++;
                    else downCount++;
                    totalChange += outcome.changePercent;
                    outcomes.push({
                        ...outcome,
                        match: match
                    });
                }
            });
            
            // Display statistics
            const avgChange = validMatches > 0 ? (totalChange / validMatches) : 0;
            const upPercentage = validMatches > 0 ? (upCount / validMatches * 100) : 0;
            
            const statsContainer = document.getElementById('outcomeStats');
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <h4>Total Patterns</h4>
                    <div class="stat-value">${validMatches}</div>
                </div>
                <div class="stat-card">
                    <h4>Went Up</h4>
                    <div class="stat-value positive">${upCount}</div>
                    <div style="color: #666; margin-top: 5px;">${upPercentage.toFixed(0)}%</div>
                </div>
                <div class="stat-card">
                    <h4>Went Down</h4>
                    <div class="stat-value negative">${downCount}</div>
                    <div style="color: #666; margin-top: 5px;">${(100 - upPercentage).toFixed(0)}%</div>
                </div>
            `;
            
            // Create outcome chart
            createOutcomeChart(outcomes, lookbackDays);
            
            // Re-render match cards with new outcomes
            displayMatches(currentMatches, currentAlgorithm);
            } catch (err) {
                // Silently handle error
            }
        }

        // NEW: Create chart showing future price movements
        function createOutcomeChart(outcomes, lookbackDays) {
            try {
            try {
                if (outcomeChart) outcomeChart.destroy();
            } catch (err) {
                // Silently handle destroy error
            }
                
                const ctx = document.getElementById('outcomeChart').getContext('2d');
                
                const datasets = outcomes.map((outcome, idx) => {
                    try {
                        const normalized = normalize(outcome.futurePrices);
                        const color = outcome.direction === 'up' ? '#10b981' : '#ef4444';
                        
                        return {
                            label: `Match ${idx + 1} (${outcome.changePercent >= 0 ? '+' : ''}${outcome.changePercent.toFixed(1)}%)`,
                            data: normalized,
                            borderColor: color,
                            backgroundColor: color + '20',
                            borderWidth: 2,
                            tension: 0.3,
                            pointRadius: 0,
                            fill: false
                        };
                    } catch (err) {
                        // Silently handle error for this outcome
                        return null;
                    }
                }).filter(d => d !== null);
                
                outcomeChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: Array.from({length: lookbackDays + 1}, (_, i) => i),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: { 
                                display: false
                            },
                            title: {
                                display: true,
                                text: 'Price movement in the 30 months following the pattern',
                                font: { size: 14 }
                            }
                        },
                        scales: {
                            x: { 
                                title: { display: true, text: 'Months After Pattern', font: { size: 12 } }
                            },
                            y: { 
                                title: { display: true, text: 'Normalized Price', font: { size: 12 } }
                            }
                        }
                    }
                });
            } catch (err) {
                // Silently handle error
            }
        }
    </script>
</body>
</html>